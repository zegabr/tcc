\section{Merge Não Estrurado}
Apesar da evolução dos sistemas de controle de versão, as ferramentas utilizadas para realizar
\emph{merge} não evoluiram tanto. A ferramenta mais utilizada atualmente é o \emph{diff3}~\cite{mens02}, que consiste em uma
abordagem puramente textual baseada em linhas. Essa ferramenta, ao receber os três arquivos que configuram o cenário de merge
(chamemos de \emph{base}, \emph{left} e \emph{right}), compara, linha a linha, as duas versões modificadas
(\emph{left} e \emph{right}) com seu ancestral comum (\emph{base}), que foi o arquivo que deu origem às modificações
que vão ser integradas. APós isso, a ferramenta agrupa as maiores áreas em comum e checa se existem interseções entre as
áreas modificadas por \emph{left} e \emph{right}. Essas interseções são definidas como conflitos de merge~\cite{khan07},
elas serão sinalizadas pelo \emph{diff3} através de marcadores \verb|(">>>>>>>","=======","<<<<<<<")|, como demonstrado na
Figura \ref{diff3_example}.

Por considerar as mudanças linha a linha para detectar os conflitos, muitas vezes essa ferramenta relata falsos conflitos
de modificações que alteram a mesma linha ou linhas consecutivas, mas que não interferem entre si semanticamente.
Esse problema poderia ser resolvido utilizando ferramentas que explorem a estrutura sintática do código em questão.

Para ilustrar esse problema causado pelo \emph{merge} não estruturado, utilizamos a implementação de um método
\detokenize{to_string} que
recebe uma lista de strings e retorna uma string juntando todos os elementos da lista separados por dois
\emph{underlines} \detokenize{"__"}. Observe que as mudanças feitas pelo \emph{left} foram a adição de uma nova
condição no if, e a mudançã da string separadora do return final (modificado de ".." para \detokenize{"__"}). Por outro lado,
as mudanças feitas pelo \emph{right} foram o valor padrao de retorno de uma string vazia para uma constante (por simplicidade
consideramos que a constante foi definida na classe onde o método está sendo implementado), e a mesma
modificação que o \emph{left} fez no último return do método. Perceba que todas essas mudanças são independentes entre si,
mas por elas acontecerem em linhas consecutivas, o \emph{diff3} relata todas elas em um mesmo conflito (Figura
\ref{diff3_example}).

\begin{figure}[ht]
	\begin{center}
		\lstinputlisting[language=Python]{./example/no_indentation/base.py}
		\caption{Arquivo \emph{base} que contém o método \detokenize{to_string}}\label{base_example}
	\end{center}
\end{figure}

\begin{figure}[ht]
	\begin{center}
		\lstinputlisting[language=Python]{./example/no_indentation/left.py}
		\caption{Arquivo \emph{left} que contém o método \detokenize{to_string}}\label{left_example}
	\end{center}
\end{figure}

\begin{figure}[ht]
	\begin{center}
		\lstinputlisting[language=Python]{./example/no_indentation/right.py}
		\caption{Arquivo \emph{right} que contém o método \detokenize{to_string}}\label{right_example}
	\end{center}
\end{figure}

\begin{figure}[ht]
	\begin{center}
		\lstinputlisting[language=Python]{./example/no_indentation/diff3.py}
	\end{center}
	\caption{Resultado de executar o \emph{diff3}}\label{diff3_example}
\end{figure}

\section{Merge Semiestruturado e Estruturado}
Como alternativa ao uso de merge não estruturado, existem as abordagens
semiestruturadas ou completamente estruturadas. Ao contrário da abordagem não
estruturada, essas abordagens levam em consideração a estrutura sintática da
linguagem de programação para identificar conflitos com maior precisão e resolvê-los de
forma mais correta. Essas abordagens criam árvores sintáticas para
cada versão dos arquivos a serem integrados (\emph{base}, \emph{left} e \emph{right})
e comparam essas árvores para identificar nós comuns
e adições ou remoções em cada árvore. Dessa forma, cada elemento sintático
é representado em nós distintos, e conflitos são sinalizados quando as mudanças
a serem integradas estão relacionadas ao mesmo nó da árvore. Isso significa
que, em vez de usar linhas como a unidade básica para comparação, essas ferramentas usam
nós sintáticos como unidade.

Essas ferramentas estruturadas e semiestruturadas conseguem evitar falsos conflitos
encontrados na abordagem não estruturada. Por exemplo, duas situações em
que dois desenvolvedores adicionam separadamente dois novos métodos com diferentes
assinaturas em uma mesma área do texto podem ser conciliadas com sucesso.
As mudanças ocorrem na mesma linha, mas cada declaração é representada por
um nó diferente, pois o identificador do método é parte do nó,
e os dois nós são mantidos na árvore resultante da integração.

Dessa forma, é fácil observar que uma ferramenta estruturada para Python evitaria o
conflito apresentado na Figura \ref{diff3_example}. A ferramenta, utilizando a estrutura da
linguagem, identificaria que, apesar das mudanças representadas na Figura \ref{left_example} e na
Figura \ref{right_example} ocorrerem em linhas consecutivas (o que faz com que o \emph{diff3}
agrupe as mudanças em um único bloco de conflito),
elas estariam associadas a nós diferentes na árvore
sintática. A ferramenta então juntaria as mudanças em uma versão resultante que contém a
nova condição proposta por \emph{left} e o novo valor de retorno proposto por \emph{right},
evitando o falso conflito.

\section{Merge não Estruturado com separadores}
As abordagens estruturadas e semiestruturadas discutidas na seção anterior, apesar de claramente benéficas,
possuem um custo adicional, dado que elas se baseiam em manipulação de árvores sintáticas, que por sua vez são
dependentes da linguagem em questão e demandam um esforço significativo de implementação por linguagem, além de que
a manipulação das árvores sintáticas possui um custo computacional maior em relação a abordagens puramente textuais.

Em trabalho anterior, ~\citeauthor{clem21} propõe uma nova ferramenta chamada
\textbf{Custom Separators Diff} (\emph{CSDiff}), cujo funcionamento baseia-se na abordagem puramente textual, mas que também
considera a estrutura sintática do programa por meio de um conjunto de separadores da linguagem, escolhidos pelo usuário e
passados como parâmetro. 

TODO: copiar explicacao de como ele funciona, pseudo algoritmo

TODO: mostrar e explicar exemplo dela funcionando sem indentation

TODO: explicar a limitacao para linguagem python

TODO: mostrar exemplo dela funcionando com indentation



